{"ast":null,"code":"import \"core-js/modules/es.symbol.description\";import _indexOfInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/index-of\";import _Object$assign from \"@babel/runtime-corejs3/core-js-stable/object/assign\";import _Promise from \"@babel/runtime-corejs3/core-js-stable/promise\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import { t } from '@superset-ui/translation';\nimport COMMON_ERR_MESSAGES from './errorMessages';\nexport default function getClientErrorObject(response) {\n  // takes a SupersetClientResponse as input, attempts to read response as Json if possible,\n  // and returns a Promise that resolves to a plain object with error key and text value.\n  return new _Promise(resolve => {\n    if (typeof response === 'string') {\n      resolve({ error: response });\n    } else\n    {\n      const responseObject = response instanceof Response ? response : response.response;\n      if (responseObject && !responseObject.bodyUsed) {\n        // attempt to read the body as json, and fallback to text. we must clone the\n        // response in order to fallback to .text() because Response is single-read\n        responseObject.\n        clone().\n        json().\n        then(errorJson => {var _context;\n          let error = _Object$assign({}, responseObject, {}, errorJson);\n          // Backwards compatibility for old error renderers with the new error object\n          if (error.errors && error.errors.length > 0) {var _error$errors$, _error$errors$$extra;\n            error.error = error.description = error.errors[0].message;\n            error.link = (_error$errors$ = error.errors[0]) === null || _error$errors$ === void 0 ? void 0 : (_error$errors$$extra = _error$errors$.extra) === null || _error$errors$$extra === void 0 ? void 0 : _error$errors$$extra.link;\n          }\n          if (error.stack) {\n            error = _Object$assign({},\n            error, {\n              error: t('Unexpected error: ') + (\n              error.description ||\n              t('(no description, click to see stack trace)')),\n              stacktrace: error.stack });\n\n          } else\n          if (error.responseText &&\n          _indexOfInstanceProperty(_context = error.responseText).call(_context, 'CSRF') >= 0) {\n            error = _Object$assign({},\n            error, {\n              error: t(COMMON_ERR_MESSAGES.SESSION_TIMED_OUT) });\n\n          }\n          resolve(error);\n        }).\n        catch(() => {\n          // fall back to reading as text\n          responseObject.text().then(errorText => {\n            resolve(_Object$assign({}, responseObject, { error: errorText }));\n          });\n        });\n      } else\n      {\n        // fall back to Response.statusText or generic error of we cannot read the response\n        const error = 'statusText' in response ?\n        response.statusText :\n        t('An error occurred');\n        resolve(_Object$assign({},\n        responseObject, {\n          error }));\n\n      }\n    }\n  });\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(getClientErrorObject, \"getClientErrorObject\", \"/home/tiago/git-facilit/incubator-superset/superset-frontend/src/utils/getClientErrorObject.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":null,"metadata":{},"sourceType":"module"}