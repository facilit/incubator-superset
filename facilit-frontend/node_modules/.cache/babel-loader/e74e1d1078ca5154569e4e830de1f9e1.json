{"ast":null,"code":"import _Object$assign from \"@babel/runtime-corejs3/core-js-stable/object/assign\";import _isEqual from \"lodash/isEqual\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { CategoricalColorNamespace } from '@superset-ui/color';\nimport getEffectiveExtraFilters from './getEffectiveExtraFilters';\n// We cache formData objects so that our connected container components don't always trigger\n// render cascades. we cannot leverage the reselect library because our cache size is >1\nconst cachedFiltersByChart = {};\nconst cachedFormdataByChart = {};\n// this function merge chart's formData with dashboard filters value,\n// and generate a new formData which will be used in the new query.\n// filters param only contains those applicable to this chart.\nexport default function getFormDataWithExtraFilters({ chart, filters, colorScheme, colorNamespace, sliceId }) {\n  // Propagate color mapping to chart\n  const scale = CategoricalColorNamespace.getScale(colorScheme, colorNamespace);\n  const labelColors = scale.getColorMap();\n  // if dashboard metadata + filters have not changed, use cache if possible\n  if ((cachedFiltersByChart[sliceId] || {}) === filters && (\n  colorScheme == null ||\n  cachedFormdataByChart[sliceId].color_scheme === colorScheme) &&\n  cachedFormdataByChart[sliceId].color_namespace === colorNamespace &&\n  _isEqual(cachedFormdataByChart[sliceId].label_colors, labelColors) &&\n  !!cachedFormdataByChart[sliceId]) {\n    return cachedFormdataByChart[sliceId];\n  }\n  const formData = _Object$assign({},\n  chart.formData, {},\n  colorScheme && { color_scheme: colorScheme }, {\n    label_colors: labelColors,\n    extra_filters: getEffectiveExtraFilters(filters) });\n\n  cachedFiltersByChart[sliceId] = filters;\n  cachedFormdataByChart[sliceId] = formData;\n  return formData;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(cachedFiltersByChart, \"cachedFiltersByChart\", \"/home/tiago/git-facilit/incubator-superset/superset-frontend/src/dashboard/util/charts/getFormDataWithExtraFilters.ts\");reactHotLoader.register(cachedFormdataByChart, \"cachedFormdataByChart\", \"/home/tiago/git-facilit/incubator-superset/superset-frontend/src/dashboard/util/charts/getFormDataWithExtraFilters.ts\");reactHotLoader.register(getFormDataWithExtraFilters, \"getFormDataWithExtraFilters\", \"/home/tiago/git-facilit/incubator-superset/superset-frontend/src/dashboard/util/charts/getFormDataWithExtraFilters.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":null,"metadata":{},"sourceType":"module"}