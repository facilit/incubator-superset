{"ast":null,"code":"import \"core-js/modules/es.symbol.description\";import _indexOfInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/index-of\";import _Object$assign from \"@babel/runtime-corejs3/core-js-stable/object/assign\";import _Promise from \"@babel/runtime-corejs3/core-js-stable/promise\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import { t } from '@superset-ui/translation';\nimport COMMON_ERR_MESSAGES from './errorMessages';\nexport default function getClientErrorObject(response) {\n  // takes a SupersetClientResponse as input, attempts to read response as Json if possible,\n  // and returns a Promise that resolves to a plain object with error key and text value.\n  return new _Promise(resolve => {\n    if (typeof response === 'string') {\n      resolve({ error: response });\n    } else\n    {\n      const responseObject = response instanceof Response ? response : response.response;\n      if (responseObject && !responseObject.bodyUsed) {\n        // attempt to read the body as json, and fallback to text. we must clone the\n        // response in order to fallback to .text() because Response is single-read\n        responseObject.\n        clone().\n        json().\n        then(errorJson => {var _context;\n          let error = _Object$assign({}, responseObject, {}, errorJson);\n          // Backwards compatibility for old error renderers with the new error object\n          if (error.errors && error.errors.length > 0) {var _error$errors$, _error$errors$$extra;\n            error.error = error.description = error.errors[0].message;\n            error.link = (_error$errors$ = error.errors[0]) === null || _error$errors$ === void 0 ? void 0 : (_error$errors$$extra = _error$errors$.extra) === null || _error$errors$$extra === void 0 ? void 0 : _error$errors$$extra.link;\n          }\n          if (error.stack) {\n            error = _Object$assign({},\n            error, {\n              error: t('Unexpected error: ') + (\n              error.description ||\n              t('(no description, click to see stack trace)')),\n              stacktrace: error.stack });\n\n          } else\n          if (error.responseText &&\n          _indexOfInstanceProperty(_context = error.responseText).call(_context, 'CSRF') >= 0) {\n            error = _Object$assign({},\n            error, {\n              error: t(COMMON_ERR_MESSAGES.SESSION_TIMED_OUT) });\n\n          }\n          resolve(error);\n        }).\n        catch(() => {\n          // fall back to reading as text\n          responseObject.text().then(errorText => {\n            resolve(_Object$assign({}, responseObject, { error: errorText }));\n          });\n        });\n      } else\n      {\n        // fall back to Response.statusText or generic error of we cannot read the response\n        const error = 'statusText' in response ?\n        response.statusText :\n        t('An error occurred');\n        resolve(_Object$assign({},\n        responseObject, {\n          error }));\n\n      }\n    }\n  });\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(getClientErrorObject, \"getClientErrorObject\", \"/home/tiago/git-facilit/incubator-superset/superset-frontend/src/utils/getClientErrorObject.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/home/tiago/git-facilit/incubator-superset/superset-frontend/src/utils/getClientErrorObject.ts"],"names":[],"mappings":"2kBAmBA,SAAS,CAAT,QAAkB,0BAAlB;AAEA,OAAO,mBAAP,MAAgC,iBAAhC;AAaA,eAAc,SAAU,oBAAV,CACZ,QADY,EAC6B;AAEzC;AACA;AACA,SAAO,aAAY,OAAO,IAAG;AAC3B,QAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC;AAChC,MAAA,OAAO,CAAC,EAAE,KAAK,EAAE,QAAT,EAAD,CAAP;AACD,KAFD;AAEO;AACL,YAAM,cAAc,GAClB,QAAQ,YAAY,QAApB,GAA+B,QAA/B,GAA0C,QAAQ,CAAC,QADrD;AAEA,UAAI,cAAc,IAAI,CAAC,cAAc,CAAC,QAAtC,EAAgD;AAC9C;AACA;AACA,QAAA,cAAc;AACX,QAAA,KADH;AAEG,QAAA,IAFH;AAGG,QAAA,IAHH,CAGQ,SAAS,IAAG;AAChB,cAAI,KAAK,sBAAQ,cAAR,MAA2B,SAA3B,CAAT;AAEA;AACA,cAAI,KAAK,CAAC,MAAN,IAAgB,KAAK,CAAC,MAAN,CAAa,MAAb,GAAsB,CAA1C,EAA6C;AAC3C,YAAA,KAAK,CAAC,KAAN,GAAc,KAAK,CAAC,WAAN,GAAoB,KAAK,CAAC,MAAN,CAAa,CAAb,EAAgB,OAAlD;AACA,YAAA,KAAK,CAAC,IAAN,qBAAa,KAAK,CAAC,MAAN,CAAa,CAAb,CAAb,2EAAa,eAAiB,KAA9B,yDAAa,qBAAwB,IAArC;AACD;AAED,cAAI,KAAK,CAAC,KAAV,EAAiB;AACf,YAAA,KAAK;AACA,YAAA,KADA;AAEH,cAAA,KAAK,EACH,CAAC,CAAC,oBAAD,CAAD;AACC,cAAA,KAAK,CAAC,WAAN;AACC,cAAA,CAAC,CAAC,4CAAD,CAFH,CAHC;AAMH,cAAA,UAAU,EAAE,KAAK,CAAC,KANf,GAAL;;AAQD,WATD;AASO,cACL,KAAK,CAAC,YAAN;AACA,8CAAA,KAAK,CAAC,YAAN,iBAA2B,MAA3B,KAAsC,CAFjC,EAGL;AACA,YAAA,KAAK;AACA,YAAA,KADA;AAEH,cAAA,KAAK,EAAE,CAAC,CAAC,mBAAmB,CAAC,iBAArB,CAFL,GAAL;;AAID;AACD,UAAA,OAAO,CAAC,KAAD,CAAP;AACD,SA/BH;AAgCG,QAAA,KAhCH,CAgCS,MAAK;AACV;AACA,UAAA,cAAc,CAAC,IAAf,GAAsB,IAAtB,CAA2B,SAAS,IAAG;AACrC,YAAA,OAAO,oBAAM,cAAN,IAAsB,KAAK,EAAE,SAA7B,IAAP;AACD,WAFD;AAGD,SArCH;AAsCD,OAzCD;AAyCO;AACL;AACA,cAAM,KAAK,GACT,gBAAgB,QAAhB;AACI,QAAA,QAAQ,CAAC,UADb;AAEI,QAAA,CAAC,CAAC,mBAAD,CAHP;AAIA,QAAA,OAAO;AACF,QAAA,cADE;AAEL,UAAA,KAFK,IAAP;;AAID;AACF;AACF,GA3DM,CAAP;AA4DD,C,iLAjEuB,oB","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { SupersetClientResponse } from '@superset-ui/connection';\nimport { t } from '@superset-ui/translation';\nimport { SupersetError } from 'src/components/ErrorMessage/types';\nimport COMMON_ERR_MESSAGES from './errorMessages';\n\n// The response always contains an error attribute, can contain anything from the\n// SupersetClientResponse object, and can contain a spread JSON blob\nexport type ClientErrorObject = {\n  error: string;\n  errors?: SupersetError[];\n  link?: string;\n  message?: string;\n  severity?: string;\n  stacktrace?: string;\n} & Partial<SupersetClientResponse>;\n\nexport default function getClientErrorObject(\n  response: SupersetClientResponse | string,\n): Promise<ClientErrorObject> {\n  // takes a SupersetClientResponse as input, attempts to read response as Json if possible,\n  // and returns a Promise that resolves to a plain object with error key and text value.\n  return new Promise(resolve => {\n    if (typeof response === 'string') {\n      resolve({ error: response });\n    } else {\n      const responseObject =\n        response instanceof Response ? response : response.response;\n      if (responseObject && !responseObject.bodyUsed) {\n        // attempt to read the body as json, and fallback to text. we must clone the\n        // response in order to fallback to .text() because Response is single-read\n        responseObject\n          .clone()\n          .json()\n          .then(errorJson => {\n            let error = { ...responseObject, ...errorJson };\n\n            // Backwards compatibility for old error renderers with the new error object\n            if (error.errors && error.errors.length > 0) {\n              error.error = error.description = error.errors[0].message;\n              error.link = error.errors[0]?.extra?.link;\n            }\n\n            if (error.stack) {\n              error = {\n                ...error,\n                error:\n                  t('Unexpected error: ') +\n                  (error.description ||\n                    t('(no description, click to see stack trace)')),\n                stacktrace: error.stack,\n              };\n            } else if (\n              error.responseText &&\n              error.responseText.indexOf('CSRF') >= 0\n            ) {\n              error = {\n                ...error,\n                error: t(COMMON_ERR_MESSAGES.SESSION_TIMED_OUT),\n              };\n            }\n            resolve(error);\n          })\n          .catch(() => {\n            // fall back to reading as text\n            responseObject.text().then(errorText => {\n              resolve({ ...responseObject, error: errorText });\n            });\n          });\n      } else {\n        // fall back to Response.statusText or generic error of we cannot read the response\n        const error =\n          'statusText' in response\n            ? response.statusText\n            : t('An error occurred');\n        resolve({\n          ...responseObject,\n          error,\n        });\n      }\n    }\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}