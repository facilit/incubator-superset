{"ast":null,"code":"import \"core-js/modules/es.symbol.description\";import _Date$now from \"@babel/runtime-corejs3/core-js-stable/date/now\";import _Array$from from \"@babel/runtime-corejs3/core-js-stable/array/from\";import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";import _reduceInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/reduce\";import _sliceInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/slice\";import _indexOfInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/index-of\";import _Set from \"@babel/runtime-corejs3/core-js-stable/set\";import _Object$values from \"@babel/runtime-corejs3/core-js-stable/object/values\";import _Object$keys from \"@babel/runtime-corejs3/core-js-stable/object/keys\";import _forEachInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/for-each\";import _Object$assign from \"@babel/runtime-corejs3/core-js-stable/object/assign\";import _isString from \"lodash/isString\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport shortid from 'shortid';\nimport { CategoricalColorNamespace } from '@superset-ui/color';\n\nimport { chart } from '../../chart/chartReducer';\nimport {\nDASHBOARD_FILTER_SCOPE_GLOBAL,\ndashboardFilter } from\n'./dashboardFilters';\nimport { initSliceEntities } from './sliceEntities';\nimport { getParam } from '../../modules/utils';\nimport { applyDefaultFormData } from '../../explore/store';\nimport { buildActiveFilters } from '../util/activeDashboardFilters';\nimport {\nBUILDER_PANE_TYPE,\nDASHBOARD_HEADER_ID,\nGRID_DEFAULT_CHART_WIDTH,\nGRID_COLUMN_COUNT } from\n'../util/constants';\nimport {\nDASHBOARD_HEADER_TYPE,\nCHART_TYPE,\nROW_TYPE } from\n'../util/componentTypes';\nimport { buildFilterColorMap } from '../util/dashboardFiltersColorMap';\nimport findFirstParentContainerId from '../util/findFirstParentContainer';\nimport getEmptyLayout from '../util/getEmptyLayout';\nimport getFilterConfigsFromFormdata from '../util/getFilterConfigsFromFormdata';\nimport getLocationHash from '../util/getLocationHash';\nimport newComponentFactory from '../util/newComponentFactory';\nimport { TIME_RANGE } from '../../visualizations/FilterBox/FilterBox';const _default =\n\nfunction _default(bootstrapData) {var _context2, _context3;\n  const { user_id, datasources, common, editMode, urlParams } = bootstrapData;\n\n  const dashboard = _Object$assign({}, bootstrapData.dashboard_data);\n  let preselectFilters = {};\n  try {\n    // allow request parameter overwrite dashboard metadata\n    preselectFilters = JSON.parse(\n    getParam('preselect_filters') || dashboard.metadata.default_filters);\n\n  } catch (e) {\n\n  } //\n\n  // Priming the color palette with user's label-color mapping provided in\n  // the dashboard's JSON metadata\n  if (dashboard.metadata && dashboard.metadata.label_colors) {var _context;\n    const scheme = dashboard.metadata.color_scheme;\n    const namespace = dashboard.metadata.color_namespace;\n    const colorMap = _isString(dashboard.metadata.label_colors) ?\n    JSON.parse(dashboard.metadata.label_colors) :\n    dashboard.metadata.label_colors;\n    _forEachInstanceProperty(_context = _Object$keys(colorMap)).call(_context, label => {\n      CategoricalColorNamespace.getScale(scheme, namespace).setColor(\n      label,\n      colorMap[label]);\n\n    });\n  }\n\n  // dashboard layout\n  const { position_json: positionJson } = dashboard;\n  // new dash: positionJson could be {} or null\n  const layout =\n  positionJson && _Object$keys(positionJson).length > 0 ?\n  positionJson :\n  getEmptyLayout();\n\n  // create a lookup to sync layout names with slice names\n  const chartIdToLayoutId = {};\n  _forEachInstanceProperty(_context2 = _Object$values(layout)).call(_context2, layoutComponent => {\n    if (layoutComponent.type === CHART_TYPE) {\n      chartIdToLayoutId[layoutComponent.meta.chartId] = layoutComponent.id;\n    }\n  });\n\n  // find root level chart container node for newly-added slices\n  const parentId = findFirstParentContainerId(layout);\n  const parent = layout[parentId];\n  let newSlicesContainer;\n  let newSlicesContainerWidth = 0;\n\n  const filterScopes = dashboard.metadata.filter_scopes || {};\n\n  const chartQueries = {};\n  const dashboardFilters = {};\n  const slices = {};\n  const sliceIds = new _Set();\n  _forEachInstanceProperty(_context3 = dashboard.slices).call(_context3, slice => {var _context4;\n    const key = slice.slice_id;\n    if (_indexOfInstanceProperty(_context4 = ['separator', 'markup']).call(_context4, slice.form_data.viz_type) === -1) {\n      const form_data = _Object$assign({},\n      slice.form_data, {\n        url_params: _Object$assign({},\n        slice.form_data.url_params, {},\n        urlParams) });\n\n\n      chartQueries[key] = _Object$assign({},\n      chart, {\n        id: key,\n        form_data,\n        formData: applyDefaultFormData(form_data) });\n\n\n      slices[key] = {\n        slice_id: key,\n        slice_url: slice.slice_url,\n        slice_name: slice.slice_name,\n        form_data: slice.form_data,\n        edit_url: slice.edit_url,\n        viz_type: slice.form_data.viz_type,\n        datasource: slice.form_data.datasource,\n        description: slice.description,\n        description_markeddown: slice.description_markeddown,\n        modified: slice.modified,\n        changed_on: new Date(slice.changed_on).getTime() };\n\n\n      sliceIds.add(key);\n\n      // if there are newly added slices from explore view, fill slices into 1 or more rows\n      if (!chartIdToLayoutId[key] && layout[parentId]) {var _context6;\n        if (\n        newSlicesContainerWidth === 0 ||\n        newSlicesContainerWidth + GRID_DEFAULT_CHART_WIDTH > GRID_COLUMN_COUNT)\n        {var _context5;\n          newSlicesContainer = newComponentFactory(\n          ROW_TYPE,\n          _sliceInstanceProperty(_context5 = parent.parents || []).call(_context5));\n\n          layout[newSlicesContainer.id] = newSlicesContainer;\n          parent.children.push(newSlicesContainer.id);\n          newSlicesContainerWidth = 0;\n        }\n\n        const chartHolder = newComponentFactory(\n        CHART_TYPE,\n        {\n          chartId: slice.slice_id },\n\n        _sliceInstanceProperty(_context6 = newSlicesContainer.parents || []).call(_context6));\n\n\n        layout[chartHolder.id] = chartHolder;\n        newSlicesContainer.children.push(chartHolder.id);\n        chartIdToLayoutId[chartHolder.meta.chartId] = chartHolder.id;\n        newSlicesContainerWidth += GRID_DEFAULT_CHART_WIDTH;\n      }\n\n      // build DashboardFilters for interactive filter features\n      if (slice.form_data.viz_type === 'filter_box') {var _context8, _context9, _context10;\n        const configs = getFilterConfigsFromFormdata(slice.form_data);\n        let columns = configs.columns;\n        const labels = configs.labels;\n        if (preselectFilters[key]) {var _context7;\n          _forEachInstanceProperty(_context7 = _Object$keys(columns)).call(_context7, col => {\n            if (preselectFilters[key][col]) {\n              columns = _Object$assign({},\n              columns, {\n                [col]: preselectFilters[key][col] });\n\n            }\n          });\n        }\n\n        const scopesByChartId = _reduceInstanceProperty(_context8 = _Object$keys(columns)).call(_context8, (map, column) => {\n          const scopeSettings = _Object$assign({},\n          filterScopes[key]);\n\n          const { scope, immune } = _Object$assign({},\n          DASHBOARD_FILTER_SCOPE_GLOBAL, {},\n          scopeSettings[column]);\n\n\n          return _Object$assign({},\n          map, {\n            [column]: {\n              scope,\n              immune } });\n\n\n        }, {});\n\n        const componentId = chartIdToLayoutId[key];\n        const directPathToFilter = _sliceInstanceProperty(_context9 = layout[componentId].parents || []).call(_context9);\n        directPathToFilter.push(componentId);\n        dashboardFilters[key] = _Object$assign({},\n        dashboardFilter, {\n          chartId: key,\n          componentId,\n          datasourceId: slice.form_data.datasource,\n          filterName: slice.slice_name,\n          directPathToFilter,\n          columns,\n          labels,\n          scopes: scopesByChartId,\n          isInstantFilter: !!slice.form_data.instant_filtering,\n          isDateFilter: _includesInstanceProperty(_context10 = _Object$keys(columns)).call(_context10, TIME_RANGE) });\n\n      }\n    }\n\n    // sync layout names with current slice names in case a slice was edited\n    // in explore since the layout was updated. name updates go through layout for undo/redo\n    // functionality and python updates slice names based on layout upon dashboard save\n    const layoutId = chartIdToLayoutId[key];\n    if (layoutId && layout[layoutId]) {\n      layout[layoutId].meta.sliceName = slice.slice_name;\n    }\n  });\n  buildActiveFilters({\n    dashboardFilters,\n    components: layout });\n\n  buildFilterColorMap(dashboardFilters, layout);\n\n  // store the header as a layout component so we can undo/redo changes\n  layout[DASHBOARD_HEADER_ID] = {\n    id: DASHBOARD_HEADER_ID,\n    type: DASHBOARD_HEADER_TYPE,\n    meta: {\n      text: dashboard.dashboard_title } };\n\n\n\n  const dashboardLayout = {\n    past: [],\n    present: layout,\n    future: [] };\n\n\n  // find direct link component and path from root\n  const directLinkComponentId = getLocationHash();\n  let directPathToChild = [];\n  if (layout[directLinkComponentId]) {var _context11;\n    directPathToChild = _sliceInstanceProperty(_context11 = layout[directLinkComponentId].parents || []).call(_context11);\n    directPathToChild.push(directLinkComponentId);\n  }\n\n  return {\n    datasources,\n    sliceEntities: _Object$assign({}, initSliceEntities, { slices, isLoading: false }),\n    charts: chartQueries,\n    // read-only data\n    dashboardInfo: {\n      id: dashboard.id,\n      slug: dashboard.slug,\n      metadata: dashboard.metadata,\n      userId: user_id,\n      dash_edit_perm: dashboard.dash_edit_perm,\n      dash_save_perm: dashboard.dash_save_perm,\n      superset_can_explore: dashboard.superset_can_explore,\n      superset_can_csv: dashboard.superset_can_csv,\n      slice_can_edit: dashboard.slice_can_edit,\n      common: {\n        flash_messages: common.flash_messages,\n        conf: common.conf } },\n\n\n    dashboardFilters,\n    dashboardState: {\n      sliceIds: _Array$from(sliceIds),\n      directPathToChild,\n      directPathLastUpdated: _Date$now(),\n      // dashboard only has 1 focused filter field at a time,\n      // but when user switch different filter boxes,\n      // browser didn't always fire onBlur and onFocus events in order.\n      // so in redux state focusedFilterField prop is a queue,\n      // but component use focusedFilterField prop as single object.\n      focusedFilterField: [],\n      expandedSlices: dashboard.metadata.expanded_slices || {},\n      refreshFrequency: dashboard.metadata.refresh_frequency || 0,\n      // dashboard viewers can set refresh frequency for the current visit,\n      // only persistent refreshFrequency will be saved to backend\n      shouldPersistRefreshFrequency: false,\n      css: dashboard.css || '',\n      colorNamespace: dashboard.metadata.color_namespace,\n      colorScheme: dashboard.metadata.color_scheme,\n      editMode: dashboard.dash_edit_perm && editMode,\n      isPublished: dashboard.published,\n      builderPaneType:\n      dashboard.dash_edit_perm && editMode ?\n      BUILDER_PANE_TYPE.ADD_COMPONENTS :\n      BUILDER_PANE_TYPE.NONE,\n      hasUnsavedChanges: false,\n      maxUndoHistoryExceeded: false },\n\n    dashboardLayout,\n    messageToasts: [],\n    impressionId: shortid.generate() };\n\n};export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(_default, \"default\", \"/home/tiago/git-facilit/incubator-superset/superset-frontend/src/dashboard/reducers/getInitialState.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":null,"metadata":{},"sourceType":"module"}