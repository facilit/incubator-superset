"use strict";

exports.__esModule = true;
exports.default = isPropertySupportedByScaleType;

var _VegaLite = require("../../types/VegaLite");

var _scaleCategories = require("./scaleCategories");

const pointOrBand = [_VegaLite.ScaleType.POINT, _VegaLite.ScaleType.BAND];
const pointOrBandSet = new Set(pointOrBand);

const exceptPointOrBand = _scaleCategories.allScaleTypes.filter(type => !pointOrBandSet.has(type));

const exceptPointOrBandSet = new Set(exceptPointOrBand);
const continuousOrPointOrBandSet = new Set(_scaleCategories.continuousScaleTypes.concat(pointOrBand));
const zeroSet = new Set(_scaleCategories.continuousDomainScaleTypes); // log scale cannot have zero value

zeroSet.delete(_VegaLite.ScaleType.LOG); // zero is not meaningful for time

zeroSet.delete(_VegaLite.ScaleType.TIME);
zeroSet.delete(_VegaLite.ScaleType.UTC); // threshold requires custom domain so zero does not matter

zeroSet.delete(_VegaLite.ScaleType.THRESHOLD); // quantile depends on distribution so zero does not matter

zeroSet.delete(_VegaLite.ScaleType.QUANTILE);
const supportedScaleTypes = {
  align: pointOrBandSet,
  base: new Set([_VegaLite.ScaleType.LOG]),
  clamp: _scaleCategories.continuousScaleTypesSet,
  constant: new Set([_VegaLite.ScaleType.SYMLOG]),
  domain: _scaleCategories.allScaleTypesSet,
  exponent: new Set([_VegaLite.ScaleType.POW]),
  interpolate: exceptPointOrBandSet,
  namespace: new Set([_VegaLite.ScaleType.ORDINAL]),
  nice: new Set(_scaleCategories.continuousScaleTypes.concat([_VegaLite.ScaleType.QUANTIZE, _VegaLite.ScaleType.THRESHOLD])),
  padding: continuousOrPointOrBandSet,
  paddingInner: new Set([_VegaLite.ScaleType.BAND]),
  paddingOuter: pointOrBandSet,
  range: _scaleCategories.allScaleTypesSet,
  reverse: _scaleCategories.allScaleTypesSet,
  round: continuousOrPointOrBandSet,
  scheme: exceptPointOrBandSet,
  zero: zeroSet
};

function isPropertySupportedByScaleType(property, scaleType) {
  return supportedScaleTypes[property].has(scaleType);
}