import { ValueDef, Value, Type } from './VegaLite';
import { WithScale } from './Scale';
import { WithXAxis, WithYAxis } from './Axis';
import { WithLegend } from './Legend';
export declare type PropertyValue = {
    [key: string]: any;
} | boolean | null | undefined;
export declare type Formatter = (d: unknown) => string;
export interface FieldDef {
    field: string;
    format?: string;
    title?: string;
    bin?: boolean;
}
export interface TypedFieldDef extends FieldDef {
    type: Type;
}
export declare type TextFieldDef = FieldDef;
export declare type ScaleFieldDef<Output extends Value = Value> = TypedFieldDef & WithScale<Output>;
export declare type MarkPropFieldDef<Output extends Value = Value> = ScaleFieldDef<Output> & WithLegend;
declare type PositionFieldDefBase<Output extends Value = Value> = ScaleFieldDef<Output>;
export declare type XFieldDef<Output extends Value = Value> = PositionFieldDefBase<Output> & WithXAxis;
export declare type YFieldDef<Output extends Value = Value> = PositionFieldDefBase<Output> & WithYAxis;
export declare type PositionFieldDef<Output extends Value = Value> = XFieldDef<Output> | YFieldDef<Output>;
export declare type MarkPropChannelDef<Output extends Value = Value> = MarkPropFieldDef<Output> | ValueDef<Output>;
export declare type TextChannelDef<Output extends Value = Value> = TextFieldDef | ValueDef<Output>;
export declare type ChannelDef<Output extends Value = Value> = ValueDef<Output> | XFieldDef<Output> | YFieldDef<Output> | MarkPropFieldDef<Output> | TextFieldDef;
/** Channel definitions that are not constant value */
export declare type NonValueDef<Output extends Value = Value> = Exclude<ChannelDef<Output>, ValueDef<Output>>;
/** Pattern for extracting output type from channel definition */
export declare type ExtractChannelOutput<Def> = Def extends ChannelDef<infer Output> ? Output : never;
export {};
//# sourceMappingURL=ChannelDef.d.ts.map