"use strict";

exports.__esModule = true;
exports.default = void 0;

var _createFormatterFromFieldTypeAndFormat = _interopRequireDefault(require("../parsers/format/createFormatterFromFieldTypeAndFormat"));

var _VegaLite = require("../types/VegaLite");

var _parseDateTime = _interopRequireDefault(require("../parsers/parseDateTime"));

var _inferElementTypeFromUnionOfArrayTypes = _interopRequireDefault(require("../utils/inferElementTypeFromUnionOfArrayTypes"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ChannelEncoderAxis {
  constructor(channelEncoder) {
    var _this$config$format;

    this.channelEncoder = void 0;
    this.config = void 0;
    this.formatValue = void 0;
    this.channelEncoder = channelEncoder;
    this.config = channelEncoder.definition.axis;
    this.formatValue = (0, _createFormatterFromFieldTypeAndFormat.default)(channelEncoder.definition.type, (_this$config$format = this.config.format) != null ? _this$config$format : '');
  }

  getTitle() {
    return this.config.title;
  }

  hasTitle() {
    const {
      title
    } = this.config;
    return title !== null && typeof title !== 'undefined' && title !== '';
  }

  getTickLabels() {
    const {
      tickCount,
      values
    } = this.config;

    if (typeof values !== 'undefined') {
      return (0, _inferElementTypeFromUnionOfArrayTypes.default)(values).map(v => this.formatValue((0, _VegaLite.isDateTime)(v) ? (0, _parseDateTime.default)(v) : v));
    }

    const {
      scale
    } = this.channelEncoder;

    if (scale && 'domain' in scale) {
      const ticks = 'ticks' in scale ? scale.ticks(tickCount) : scale.domain();
      return ticks.map(this.formatValue);
    }

    return [];
  }

}

exports.default = ChannelEncoderAxis;