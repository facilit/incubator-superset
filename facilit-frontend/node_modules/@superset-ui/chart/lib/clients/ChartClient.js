"use strict";

exports.__esModule = true;
exports.default = void 0;

var _core = require("@superset-ui/core");

var _connection = require("@superset-ui/connection");

var _ChartBuildQueryRegistrySingleton = _interopRequireDefault(require("../registries/ChartBuildQueryRegistrySingleton"));

var _ChartMetadataRegistrySingleton = _interopRequireDefault(require("../registries/ChartMetadataRegistrySingleton"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class ChartClient {
  constructor(config = {}) {
    _defineProperty(this, "client", void 0);

    const {
      client = _connection.SupersetClient
    } = config;
    this.client = client;
  }

  loadFormData(input, options) {
    /* If sliceId is provided, use it to fetch stored formData from API */
    if ('sliceId' in input) {
      const promise = this.client.get(_extends({
        endpoint: "/api/v1/form_data/?slice_id=" + input.sliceId
      }, options)).then(response => response.json);
      /*
       * If formData is also specified, override API result
       * with user-specified formData
       */

      return promise.then(dbFormData => _extends({}, dbFormData, {}, input.formData));
    }
    /* If sliceId is not provided, returned formData wrapped in a Promise */


    return input.formData ? Promise.resolve(input.formData) : Promise.reject(new Error('At least one of sliceId or formData must be specified'));
  }

  async loadQueryData(formData, options) {
    const {
      viz_type: visType
    } = formData;
    const metaDataRegistry = (0, _ChartMetadataRegistrySingleton.default)();
    const buildQueryRegistry = (0, _ChartBuildQueryRegistrySingleton.default)();

    if (metaDataRegistry.has(visType)) {
      var _await$buildQueryRegi;

      const {
        useLegacyApi
      } = metaDataRegistry.get(visType);
      const buildQuery = (_await$buildQueryRegi = await buildQueryRegistry.get(visType)) != null ? _await$buildQueryRegi : () => formData;
      return this.client.post(_extends({
        headers: {
          'Content-Type': 'application/json'
        },
        endpoint: useLegacyApi ? '/superset/explore_json/' : '/api/v1/chart/data',
        postPayload: {
          [useLegacyApi ? 'form_data' : 'query_context']: buildQuery(formData)
        }
      }, options)).then(response => {
        // let's assume response.json always has the shape of QueryData
        return response.json;
      });
    }

    return Promise.reject(new Error("Unknown chart type: " + visType));
  }

  loadDatasource(datasourceKey, options) {
    return this.client.get(_extends({
      endpoint: "/superset/fetch_datasource_metadata?datasourceKey=" + datasourceKey
    }, options)).then(response => response.json);
  } // eslint-disable-next-line class-methods-use-this


  loadAnnotation(annotationLayer) {
    /* When annotation does not require query */
    if (!(0, _core.isDefined)(annotationLayer.sourceType)) {
      return Promise.resolve({});
    } // TODO: Implement


    return Promise.reject(new Error('This feature is not implemented yet.'));
  }

  loadAnnotations(annotationLayers) {
    if (Array.isArray(annotationLayers) && annotationLayers.length > 0) {
      return Promise.all(annotationLayers.map(layer => this.loadAnnotation(layer))).then(results => annotationLayers.reduce((prev, layer, i) => {
        const output = prev;
        output[layer.name] = results[i];
        return output;
      }, {}));
    }

    return Promise.resolve({});
  }

  loadChartData(input) {
    return this.loadFormData(input).then(formData => Promise.all([this.loadAnnotations(formData.annotation_layers), this.loadDatasource(formData.datasource), this.loadQueryData(formData)]).then(([annotationData, datasource, queryData]) => ({
      annotationData,
      datasource,
      formData,
      queryData
    })));
  }

}

exports.default = ChartClient;