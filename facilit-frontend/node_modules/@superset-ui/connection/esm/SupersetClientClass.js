"use strict";

exports.__esModule = true;
exports.default = void 0;

var _callApi = _interopRequireDefault(require("./callApi"));

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class SupersetClientClass {
  constructor({
    protocol = 'http:',
    host = 'localhost',
    headers = {},
    fetchRetryOptions = {},
    mode = 'same-origin',
    timeout,
    credentials = undefined,
    csrfToken = undefined
  } = {}) {
    _defineProperty(this, "credentials", void 0);

    _defineProperty(this, "csrfToken", void 0);

    _defineProperty(this, "csrfPromise", void 0);

    _defineProperty(this, "fetchRetryOptions", void 0);

    _defineProperty(this, "protocol", void 0);

    _defineProperty(this, "host", void 0);

    _defineProperty(this, "headers", void 0);

    _defineProperty(this, "mode", void 0);

    _defineProperty(this, "timeout", void 0);

    this.headers = _extends({}, headers);
    this.host = host;
    this.mode = mode;
    this.timeout = timeout;
    this.protocol = protocol;
    this.credentials = credentials;
    this.csrfToken = csrfToken;
    this.csrfPromise = undefined;
    this.fetchRetryOptions = _extends({}, _constants.DEFAULT_FETCH_RETRY_OPTIONS, {}, fetchRetryOptions);

    if (typeof this.csrfToken === 'string') {
      this.headers = _extends({}, this.headers, {
        'X-CSRFToken': this.csrfToken
      });
      this.csrfPromise = Promise.resolve(this.csrfToken);
    }
  }

  init(force = false) {
    if (this.isAuthenticated() && !force) {
      return this.csrfPromise;
    }

    return this.getCSRFToken();
  }

  isAuthenticated() {
    // if CSRF protection is disabled in the Superset app, the token may be an empty string
    return this.csrfToken !== null && this.csrfToken !== undefined;
  }

  async get(requestConfig) {
    return this.request(_extends({}, requestConfig, {
      method: 'GET'
    }));
  }

  async delete(requestConfig) {
    return this.request(_extends({}, requestConfig, {
      method: 'DELETE'
    }));
  }

  async put(requestConfig) {
    return this.request(_extends({}, requestConfig, {
      method: 'PUT'
    }));
  }

  async post(requestConfig) {
    return this.request(_extends({}, requestConfig, {
      method: 'POST'
    }));
  }

  async request({
    body,
    credentials,
    endpoint,
    fetchRetryOptions,
    headers,
    host,
    method,
    mode,
    parseMethod,
    postPayload,
    signal,
    stringify,
    timeout,
    url
  }) {
    return this.ensureAuth().then(() => (0, _callApi.default)({
      body,
      credentials: credentials != null ? credentials : this.credentials,
      fetchRetryOptions,
      headers: _extends({}, this.headers, {}, headers),
      method,
      mode: mode != null ? mode : this.mode,
      parseMethod,
      postPayload,
      signal,
      stringify,
      timeout: timeout != null ? timeout : this.timeout,
      url: this.getUrl({
        endpoint,
        host,
        url
      })
    }));
  }

  ensureAuth() {
    var _this$csrfPromise;

    return (_this$csrfPromise = this.csrfPromise) != null ? _this$csrfPromise : Promise.reject({
      error: "SupersetClient has no CSRF token, ensure it is initialized or\n        try logging into the Superset instance at " + this.getUrl({
        endpoint: '/login'
      })
    });
  }

  async getCSRFToken() {
    this.csrfToken = undefined; // If we can request this resource successfully, it means that the user has
    // authenticated. If not we throw an error prompting to authenticate.

    this.csrfPromise = (0, _callApi.default)({
      credentials: this.credentials,
      headers: _extends({}, this.headers),
      method: 'GET',
      mode: this.mode,
      timeout: this.timeout,
      url: this.getUrl({
        endpoint: 'superset/csrf_token/'
      })
    }).then(response => {
      if (typeof response.json === 'object') {
        this.csrfToken = response.json.csrf_token;

        if (typeof this.csrfToken === 'string') {
          this.headers = _extends({}, this.headers, {
            'X-CSRFToken': this.csrfToken
          });
        }
      }

      if (!this.isAuthenticated()) {
        return Promise.reject({
          error: 'Failed to fetch CSRF token'
        });
      }

      return this.csrfToken;
    });
    return this.csrfPromise;
  }

  getUrl({
    host: inputHost,
    endpoint = '',
    url
  } = {}) {
    if (typeof url === 'string') return url;
    const host = inputHost != null ? inputHost : this.host;
    const cleanHost = host.slice(-1) === '/' ? host.slice(0, -1) : host; // no backslash

    return this.protocol + "//" + cleanHost + "/" + (endpoint[0] === '/' ? endpoint.slice(1) : endpoint);
  }

}

exports.default = SupersetClientClass;