"use strict";

exports.__esModule = true;
exports.default = transformProps;

var _lodash = require("lodash");

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function transformProps(chartProps) {
  const {
    width,
    height,
    formData,
    queryData
  } = chartProps;
  const {
    margin,
    theme
  } = formData;
  const encoding = formData.encoding;
  const data = queryData.data.map(({
    label,
    values
  }) => ({
    label,
    min: values.whisker_low,
    max: values.whisker_high,
    firstQuartile: values.Q1,
    median: values.Q2,
    thirdQuartile: values.Q3,
    outliers: values.outliers
  }));
  const isHorizontal = encoding.y.type === 'nominal';
  const boxPlotValues = data.reduce((r, e) => {
    r.push(e.min, e.max, ...e.outliers);
    return r;
  }, []);
  const minBoxPlotValue = Math.min(...boxPlotValues);
  const maxBoxPlotValue = Math.max(...boxPlotValues);
  const valueDomain = [minBoxPlotValue - 0.1 * Math.abs(minBoxPlotValue), maxBoxPlotValue + 0.1 * Math.abs(maxBoxPlotValue)];

  if (isHorizontal) {
    if (encoding.x.scale) {
      encoding.x.scale.domain = valueDomain;
    } else {
      encoding.x.scale = {
        domain: valueDomain
      };
    }
  } else if (encoding.y.scale) {
    encoding.y.scale.domain = valueDomain;
  } else {
    encoding.y.scale = {
      domain: valueDomain
    };
  }

  const hooks = chartProps.hooks;
  const fieldsFromHooks = ['TooltipRenderer', 'LegendRenderer', 'LegendGroupRenderer', 'LegendItemRenderer', 'LegendItemMarkRenderer', 'LegendItemLabelRenderer'];
  return _extends({
    data,
    width,
    height,
    margin,
    theme,
    encoding
  }, (0, _lodash.pick)(hooks, fieldsFromHooks));
}