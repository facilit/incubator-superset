"use strict";

exports.__esModule = true;
exports.default = callApi;

require("whatwg-fetch");

var _fetchRetry = _interopRequireDefault(require("fetch-retry"));

var _constants = require("../constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

// This function fetches an API response and returns the corresponding json
function callApi({
  body,
  cache = 'default',
  credentials = 'same-origin',
  fetchRetryOptions,
  headers,
  method = 'GET',
  mode = 'same-origin',
  postPayload,
  redirect = 'follow',
  signal,
  stringify = true,
  url
}) {
  const fetchWithRetry = (0, _fetchRetry.default)(fetch, fetchRetryOptions);
  const request = {
    body,
    cache,
    credentials,
    headers,
    method,
    mode,
    redirect,
    signal
  };

  if (method === 'GET' && _constants.CACHE_AVAILABLE && (self.location && self.location.protocol) === 'https:') {
    return caches.open(_constants.CACHE_KEY).then(supersetCache => supersetCache.match(url).then(cachedResponse => {
      if (cachedResponse) {
        // if we have a cached response, send its ETag in the
        // `If-None-Match` header in a conditional request
        const etag = cachedResponse.headers.get('Etag');
        request.headers = _extends({}, request.headers, {
          'If-None-Match': etag
        });
      }

      return fetchWithRetry(url, request);
    }).then(response => {
      if (response.status === _constants.HTTP_STATUS_NOT_MODIFIED) {
        return supersetCache.match(url).then(cachedResponse => {
          if (cachedResponse) {
            return cachedResponse.clone();
          }

          throw new Error('Received 304 but no content is cached!');
        });
      }

      if (response.status === _constants.HTTP_STATUS_OK && response.headers.get('Etag')) {
        supersetCache.delete(url);
        supersetCache.put(url, response.clone());
      }

      return response;
    }));
  }

  if ((method === 'POST' || method === 'PATCH' || method === 'PUT') && typeof postPayload === 'object') {
    // using FormData has the effect that Content-Type header is set to `multipart/form-data`,
    // not e.g., 'application/x-www-form-urlencoded'
    const formData = new FormData();
    Object.keys(postPayload).forEach(key => {
      const value = postPayload[key];

      if (typeof value !== 'undefined') {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        formData.append(key, stringify ? JSON.stringify(value) : value);
      }
    });
    request.body = formData;
  }

  return fetchWithRetry(url, request);
}