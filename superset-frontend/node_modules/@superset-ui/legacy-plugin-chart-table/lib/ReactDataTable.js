"use strict";

exports.__esModule = true;
exports.default = ReactDataTable;

var _translation = require("@superset-ui/translation");

var _react = _interopRequireWildcard(require("react"));

var _server = _interopRequireDefault(require("react-dom/server"));

var _numberFormat = require("@superset-ui/number-format");

var _timeFormat = require("@superset-ui/time-format");

var _xss = require("xss");

var _jquery = _interopRequireDefault(require("jquery"));

var _dataTables = _interopRequireDefault(require("datatables.net-bs/js/dataTables.bootstrap"));

require("datatables.net-bs/css/dataTables.bootstrap.css");

require("./Table.css");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

// Depending on how the modules are imported, `dt` may be a CommonJS init function,
// or the DataTable class itself. In case it is the former, we'd need to tell it
// where is jQuery.
// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
if (!_dataTables.default.$) {
  // eslint-disable-next-line @typescript-eslint/no-unsafe-call
  (0, _dataTables.default)(window, _jquery.default);
}

const {
  PERCENT_3_POINT
} = _numberFormat.NumberFormats;

const isProbablyHTML = text => /<[^>]+>/.test(text);

function isTimeColumn(key) {
  return key === '__timestamp';
}

function ReactDataTable(props) {
  const {
    data,
    height,
    alignPositiveNegative = false,
    colorPositiveNegative = false,
    columns,
    includeSearch = false,
    metrics: aggMetrics,
    pageLength,
    percentMetrics,
    showCellBars = true,
    tableTimestampFormat,
    emitFilter = false,
    onChangeFilter = () => {},
    filters = {}
  } = props;
  const formatTimestamp = (0, _timeFormat.getTimeFormatter)(tableTimestampFormat);
  const metrics = (aggMetrics || []).concat(percentMetrics || []) // actual records must be of numeric types as well
  .filter(m => data.length > 0 && typeof data[0][m] === 'number'); // check whethere a key is a metric

  const aggMetricsSet = new Set(aggMetrics);
  const percentMetricsSet = new Set(percentMetrics); // collect min/max for rendering bars

  const maxes = {};
  const mins = {};
  columns.forEach(({
    key
  }) => {
    const vals = data.map(row => row[key]);

    if (metrics.includes(key)) {
      const nums = vals;

      if (alignPositiveNegative) {
        maxes[key] = Math.max(...nums.map(Math.abs));
      } else {
        maxes[key] = Math.max(...nums);
        mins[key] = Math.min(...nums);
      }
    }
  });
  const viewportHeight = Math.min(height, window.innerHeight);
  const pageLengthChoices = [10, 25, 40, 50, 75, 100, 150, 200];
  const hasPagination = pageLength > 0;
  const rootElem = (0, _react.createRef)();
  /**
   * Adjust styles after rendering the table
   */

  function drawCallback() {
    const root = rootElem.current; // force smaller pagination, because datatables-bs hard-corded pagination styles

    (0, _jquery.default)('.pagination', root).addClass('pagination-sm'); // display tr rows on current page

    (0, _jquery.default)('tr', root).css('display', '');
  }
  /**
   * Format text for cell value
   */


  function cellText(key, format, val) {
    if (isTimeColumn(key)) {
      let value = val;

      if (typeof val === 'string') {
        // force UTC time zone if is an ISO timestamp without timezone
        // e.g. "2020-10-12T00:00:00"
        value = val.match(/T(\d{2}:){2}\d{2}$/) ? val + "Z" : val;
        value = new Date(value);
      }

      return formatTimestamp(value);
    }

    if (typeof val === 'string') {
      return (0, _xss.filterXSS)(val, {
        stripIgnoreTag: true
      });
    }

    if (percentMetricsSet.has(key)) {
      // in case percent metric can specify percent format in the future
      return (0, _numberFormat.formatNumber)(format || PERCENT_3_POINT, val);
    }

    if (aggMetricsSet.has(key)) {
      // default format '' will return human readable numbers (e.g. 50M, 33k)
      return (0, _numberFormat.formatNumber)(format, val);
    }

    if (val === null) {
      return 'N/A';
    }

    return val.toString();
  }
  /**
   * Cell background to render columns as horizontal bar chart
   */


  function cellBar(key, val) {
    const r = colorPositiveNegative && val < 0 ? 150 : 0;

    if (alignPositiveNegative) {
      const perc = Math.abs(Math.round(val / maxes[key] * 100)); // The 0.01 to 0.001 is a workaround for what appears to be a
      // CSS rendering bug on flat, transparent colors

      return "linear-gradient(to right, rgba(" + r + ",0,0,0.2), rgba(" + r + ",0,0,0.2) " + perc + "%, " + ("rgba(0,0,0,0.01) " + perc + "%, rgba(0,0,0,0.001) 100%)");
    }

    const posExtent = Math.abs(Math.max(maxes[key], 0));
    const negExtent = Math.abs(Math.min(mins[key], 0));
    const tot = posExtent + negExtent;
    const perc1 = Math.round(Math.min(negExtent + val, negExtent) / tot * 100);
    const perc2 = Math.round(Math.abs(val) / tot * 100); // The 0.01 to 0.001 is a workaround for what appears to be a
    // CSS rendering bug on flat, transparent colors

    return "linear-gradient(to right, rgba(0,0,0,0.01), rgba(0,0,0,0.001) " + perc1 + "%, " + ("rgba(" + r + ",0,0,0.2) " + perc1 + "%, rgba(" + r + ",0,0,0.2) " + (perc1 + perc2) + "%, ") + ("rgba(0,0,0,0.01) " + (perc1 + perc2) + "%, rgba(0,0,0,0.001) 100%)");
  }

  function isFilterColumn(key) {
    // anything that is not a metric column is a filter column
    return !(aggMetricsSet.has(key) || percentMetricsSet.has(key));
  }

  function isActiveFilterValue(key, val) {
    var _filters$key;

    return (_filters$key = filters[key]) == null ? void 0 : _filters$key.includes(val);
  }

  const options = {
    aaSorting: [],
    // initial sorting order, reset to [] to use backend ordering
    autoWidth: false,
    paging: hasPagination,
    pagingType: 'first_last_numbers',
    pageLength,
    lengthMenu: [[...pageLengthChoices, -1], [...pageLengthChoices, (0, _translation.t)('All')]],
    searching: includeSearch,
    language: {
      paginate: {
        first: (0, _translation.t)('First'),
        last: (0, _translation.t)('Last'),
        previous: (0, _translation.t)('Previous'),
        next: (0, _translation.t)('Next')
      }
    },
    bInfo: false,
    scrollY: viewportHeight + "px",
    scrollCollapse: true,
    scrollX: true,
    drawCallback
  };
  (0, _react.useEffect)(() => {
    const $root = (0, _jquery.default)(rootElem.current);
    const dataTable = $root.find('table').DataTable(options);
    const CSS_FILTER_ACTIVE = 'dt-is-active-filter';

    function toggleFilter(key, val) {
      const cellSelector = "td[data-key=\"" + key + "\"][data-sort=\"" + val + "\"]";

      if (isActiveFilterValue(key, val)) {
        filters[key] = filters[key].filter(x => x !== val);
        $root.find(cellSelector).removeClass(CSS_FILTER_ACTIVE);
      } else {
        filters[key] = [...(filters[key] || []), val];
        $root.find(cellSelector).addClass(CSS_FILTER_ACTIVE);
      }

      onChangeFilter(_extends({}, filters));
    } // adjust table height


    const scrollHeadHeight = $root.find('.dataTables_scrollHead').height() || 0;
    const paginationHeight = $root.find('.dataTables_paginate').height() || 0;
    const searchBarHeight = $root.find('.dataTables_length,.dataTables_filter').closest('.row').height() || 0;
    const scrollBodyHeight = viewportHeight - scrollHeadHeight - paginationHeight - searchBarHeight;
    $root.find('.dataTables_scrollBody').css('max-height', scrollBodyHeight);

    if (emitFilter) {
      $root.find('tbody').on('click', 'td.dt-is-filter', function onClickCell() {
        const {
          row,
          column
        } = dataTable.cell(this).index();
        const {
          key
        } = columns[column];
        toggleFilter(key, data[row][key]);
      });
    }

    return () => {
      // there may be weird lifecycle issues, so put destroy in try/catch
      try {
        dataTable.destroy(); // reset height

        $root.find('.dataTables_scrollBody').css('max-height', '');
      } catch (error) {// pass
      }
    };
  });

  const tableElement = /*#__PURE__*/_react.default.createElement("table", {
    className: "table table-striped table-condensed table-hover"
  }, /*#__PURE__*/_react.default.createElement("thead", null, /*#__PURE__*/_react.default.createElement("tr", null, columns.map(col =>
  /*#__PURE__*/
  // by default all columns will have sorting
  _react.default.createElement("th", {
    key: col.key,
    className: "sorting",
    title: col.label
  }, col.label)))), /*#__PURE__*/_react.default.createElement("tbody", null, data.map((record, i) => /*#__PURE__*/_react.default.createElement("tr", {
    // eslint-disable-next-line react/no-array-index-key
    key: i // hide rows after first page makes the initial render faster (less layout computation)
    ,
    style: {
      display: pageLength > 0 && i >= pageLength ? 'none' : undefined
    }
  }, columns.map(({
    key,
    format
  }) => {
    const val = record[key];
    const keyIsAggMetric = aggMetricsSet.has(key);
    const text = cellText(key, format, val);
    const isHtml = !keyIsAggMetric && isProbablyHTML(text);
    const showCellBar = keyIsAggMetric && showCellBars;
    let className = '';

    if (keyIsAggMetric) {
      className += ' dt-metric';
    } else if (isFilterColumn(key) && emitFilter) {
      className += ' dt-is-filter';

      if (isActiveFilterValue(key, val)) {
        className += ' dt-is-active-filter';
      }
    }

    return /*#__PURE__*/_react.default.createElement("td", {
      key: key // only set innerHTML for actual html content, this saves time
      // eslint-disable-next-line react/no-danger
      ,
      dangerouslySetInnerHTML: isHtml ? {
        __html: text
      } : undefined,
      "data-key": key,
      "data-sort": val,
      className: className,
      style: {
        backgroundImage: showCellBar ? cellBar(key, val) : undefined
      },
      title: keyIsAggMetric || percentMetricsSet.has(key) ? String(val) : ''
    }, isHtml ? null : text);
  })))));

  return /*#__PURE__*/_react.default.createElement("div", {
    // eslint-disable-next-line react/no-danger
    dangerouslySetInnerHTML: {
      __html: _server.default.renderToStaticMarkup(tableElement)
    },
    ref: rootElem,
    className: "superset-legacy-chart-table"
  });
}